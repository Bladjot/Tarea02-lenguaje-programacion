\documentclass[11pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{hyperref}

\geometry{margin=2.5cm}

\title{Descripción Detallada del Código Go}
\author{}
\date{}

\begin{document}

\maketitle

\section{Arquitectura General}
El archivo \texttt{main.go} contiene la implementación del patrón de ejecución especulativa solicitado. Los elementos fundamentales se encuentran entre las líneas \texttt{1--608}, con la siguiente estructura:
\begin{itemize}
  \item Definiciones de constantes, errores y estructuras: \texttt{main.go:18--70}.
  \item Punto de entrada y flujo principal: \texttt{main.go:72--117}.
  \item Lectura/validación de flags y construcción de trabajos: \texttt{main.go:119--187}.
  \item Estrategia especulativa: \texttt{main.go:189--237}.
  \item Estrategia secuencial: \texttt{main.go:239--268}.
  \item Ejecución/cancelación de ramas: \texttt{main.go:271--316}.
  \item Registro de métricas en CSV: \texttt{main.go:319--427}.
  \item Funciones de apoyo (selección de rama, workloads, utilidades): \texttt{main.go:430--607}.
\end{itemize}

\section{Tipos y Configuración Inicial (\texttt{main.go:18--70})}
Se definen las constantes \texttt{branchA} y \texttt{branchB}, el error \texttt{ErrCancelled} y los structs utilizados:
\begin{itemize}
  \item \texttt{Config}: agrupa parámetros de línea de comandos (\texttt{MatrixSize}, \texttt{Threshold}, \texttt{Runs}, etc.).
  \item \texttt{BranchOutput}: encapsula el resultado numérico y un detalle textual de cada rama.
  \item \texttt{BranchWork}: tipo función que soporta cancelación (\texttt{func(cancel <-chan struct{}) (BranchOutput, error)}).
  \item \texttt{BranchResult} y \texttt{ExecutionRun}: almacenan métricas de una rama individual y de una corrida completa, respectivamente.
\end{itemize}

\section{Flujo Principal (\texttt{main.go:72--117})}
El \texttt{main} inicializa la semilla pseudoaleatoria, parsea flags y valida la configuración. Luego:
\begin{enumerate}
  \item Construye las cargas de trabajo con \texttt{buildBranchWorkload}.
  \item Ejecuta \texttt{cfg.Runs} veces la estrategia especulativa (\texttt{runSpeculative}) y secuencial (\texttt{runSequential}).
  \item Persiste resultados con \texttt{writeMetrics}.
  \item Calcula promedios y speedup mediante \texttt{averageDuration} y \texttt{computeSpeedup}, imprimiéndolos en consola.
\end{enumerate}

\section{Configuración y Validación (\texttt{main.go:119--155})}
\texttt{parseFlags} define los flags:
\texttt{-n}, \texttt{-umbral}, \texttt{-nombre\_archivo}, \texttt{-runs}, \texttt{-difficulty}, \texttt{-pow-data}, \texttt{-primes-limit}.\\
\texttt{validateConfig} asegura que los valores sean positivos y que el nombre de archivo no esté vacío; de lo contrario retorna errores descriptivos.

\section{Construcción de Trabajos (\texttt{main.go:157--187})}
\texttt{buildBranchWorkload} retorna un \texttt{map[string]BranchWork}:
\begin{itemize}
  \item Rama A: ejecuta \texttt{SimularProofOfWorkWithCancel}, captura el hash encontrado y el nonce (\texttt{int64}).
  \item Rama B: ejecuta \texttt{EncontrarPrimosWithCancel}, registrando cantidad de primos y último primo hallado.
\end{itemize}
Ambas funciones devuelven \texttt{BranchOutput} y un \texttt{error}. Si la cancelación se dispara, se propaga \texttt{ErrCancelled} para diferenciarlo de fallos reales.

\section{Estrategia Especulativa (\texttt{main.go:189--237})}
\texttt{runSpeculative} crea dos goroutines (líneas \texttt{202--203}) mediante \texttt{go executeBranchAsync(...)} para ejecutar simultáneamente las ramas A y B. Las claves:
\begin{itemize}
  \item Canales de cancelación \texttt{cancelA} y \texttt{cancelB} (líneas \texttt{199--200}).
  \item Canal \texttt{resultsCh} bufferizado (línea \texttt{197}) para recopilar resultados.
  \item Cálculo de la condición costosa con \texttt{CalcularTrazaDeProductoDeMatrices} (líneas \texttt{205--207}), decisión en \texttt{chooseBranch} (línea \texttt{209}) y cancelación del perdedor con \texttt{close(cancelX)} (líneas \texttt{210--214}).
  \item Recolección de resultados desde \texttt{resultsCh} (líneas \texttt{216--223}); si alguna rama terminó con error distinto de \texttt{ErrCancelled}, se aborta la corrida.
\end{itemize}
Finalmente se arma un \texttt{ExecutionRun} con los tiempos totales (líneas \texttt{225--236}).

\section{Estrategia Secuencial (\texttt{main.go:239--268})}
\texttt{runSequential} ejecuta la condición primero, decide el ganador y llama a \texttt{executeBranchSync} (línea \texttt{252}), que es la versión sin cancelación del trabajo. El resultado incluye una única rama en la lista de \texttt{Branches}.

\section{Ejecución de Ramas (\texttt{main.go:271--316})}
\texttt{executeBranchAsync} (líneas \texttt{271--293}) es el envoltorio usado por las goroutines:
\begin{itemize}
  \item Registra tiempos de inicio/fin con \texttt{time.Now()}.
  \item Invoca la carga de trabajo pasando el canal de cancelación.
  \item Marca los campos \texttt{Cancelled} o \texttt{Err} según el resultado.
  \item Envía el \texttt{BranchResult} al canal \texttt{out}.
\end{itemize}
\texttt{executeBranchSync} (líneas \texttt{295--316}) hace lo mismo en modo secuencial, sin canal de cancelación.

\section{Persistencia de Métricas (\texttt{main.go:319--427})}
\texttt{writeMetrics} abre \texttt{cfg.OutputFile}, escribe un encabezado y recorre todas las corridas:
\begin{itemize}
  \item Por cada rama de cada corrida genera una fila con modo, índice de corrida, ganador, cancelación, resultado numérico, detalle y métricas temporales.
  \item Añade un resumen con promedios de tiempos y speedup (líneas \texttt{396--417}).
\end{itemize}
Además emplea utilidades de formateo como \texttt{boolToString}, \texttt{floatToString} y \texttt{errorString}.

\section{Workloads y Utilidades (\texttt{main.go:430--607})}
\begin{itemize}
  \item \texttt{chooseBranch} (\texttt{430--435}) implementa la política: si la traza $\ge$ umbral, gana la rama A; si no, la B.
  \item \texttt{SimularProofOfWorkWithCancel} (\texttt{443--474}) busca un hash SHA-256 con prefijo de ceros, revisando periódicamente el canal de cancelación.
  \item \texttt{EncontrarPrimosWithCancel} (\texttt{482--518}) recorre enteros hasta \texttt{max}, testea primalidad y respeta la cancelación.
  \item \texttt{CalcularTrazaDeProductoDeMatrices} (\texttt{520--541}) genera dos matrices aleatorias y devuelve la traza de su producto.
  \item Funciones auxiliares (\texttt{544--607}) para calcular promedios, speedup, formatear strings y extraer directorios.
\end{itemize}

\section{Resumen de Concurrencia}
La creación de “nuevos hilos” en Go ocurre al lanzar goroutines:
\begin{itemize}
  \item Líneas \texttt{202--203}: \texttt{go executeBranchAsync(branchA, ...)} y \texttt{go executeBranchAsync(branchB, ...)}.
  \item Cada goroutine recibe su propio canal de cancelación; el hilo principal notifica al perdedor cerrando ese canal.
  \item \texttt{resultsCh} (línea \texttt{197}) sincroniza la recolección de resultados, permitiendo que el programa se bloquee hasta recibir ambos \texttt{BranchResult}.
\end{itemize}

\section{Conclusión}
El código implementa un comparativo claro entre ejecución especulativa y secuencial, aprovechando goroutines y canales para coordinar trabajos y cancelaciones. Las métricas detalladas permiten replicar el estudio y observar el impacto del patrón sobre los tiempos totales y el speedup.

\end{document}
